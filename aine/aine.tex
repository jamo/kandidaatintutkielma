\documentclass[finnish]{../tktltiki2}
%% Remove widow and orphan lines
\clubpenalty=10000
\widowpenalty=10000

%% Remove hyphenation
\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=1000000
\hbadness=1000000


% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
%
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{Millaisia kysymyksiä ohjelmoijat esittävät ja miten he hakevat niihin vastauksia}
\author{Jarmo Isotalo}
\date{\today}
\level{Referaatti}
\abstract{Tiivistelmä.}

% The following can be used to specify keywords and classification of the paper:

% \keywords{avainsana 1, avainsana 2, avainsana 3}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):"
% \classification{}

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
%\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering
% miksi ohjelmoijat hakevat koodia
% mistä ohjelmoijat hakevat koodia
% milloin ohjelmoijat hakevat koodia

\section{Johdanto}
Ihmiset ovat aina hakeneet apua oppiakseen ja suoriutuakseen paremmin erilaisista tehtävistä. %lol
Ohjelmistoprojektien eri vaiheiden aikana tulee esille erilaisia kysymyksiä ohjelmakoodista \cite{g_search_code}, \cite{questions-during-software-evolution-tasks}, \cite{asking-and-answering-api-questions}.
Kysymykset liittyvät niin vieraiden ohjelmistorajapintojenen (api) käyttöön \cite{jungloid-mining} kuin yleisemmin.

\section{foobar}
Mitä on koodin hakeminen
miksi koodia haetaan

S
llito, Murphy ja De Volder esittelivät Kysymyksiä, mitä kehittäjät kysyvät artikkelissaan~\cite{questions-during-software-evolution-tasks}.

- mitä ne koittaa selvittää
  - lista syistä

miten koodia haetaan
-työkalut, grep, kysyminen

Mitä koodihakuja on
- pari työkalua
Foorumit
-IRC
-Stackoverflow
-Github
-blogs

\section{Miksi ne kyselee ja mitä}
\section{Tilanteita missä tulee ongelmia }
Ohjelmoitaessa tulee usein esiin erilaisia kysymyksiä, joihin vastaamiseen noin puolet ohjelmointiajasta kuluu~\cite{eliciting-design-requirements-for-maintenance-oriented-ides}. Näiden ohjelmointitehtävään tutustuessa ja ohjelmointitehtävän aikana esiin tulleiden kysymysten avulla ohjelmoja pyrkii sisäistämään koodin toimintaa tarvittavissa määrin saadakseen tarvittavan tehtävän tehtyä. Tällaisia tehtäviä on esimerkiksi uuden ominaisuuden luominen olemassa olevaan ohjelmaan sekä ohjelmassa olevan ohjelman ohjelmointivirheen korjaaminen.

Usein kysymykseen vastausta haettaessa tulee esiin useita kysymykseen liittyviä ja sitä tarkentavia kysymyksiä, joihin vastauksia hakemalla vastaus alkuperäiseen kysymykseen tarkkenee TODO cite?

Tässä tarkastellaan erilaisia tilanteita ohjelmointityön aikana, missä tyypillisesti tulee kysymyksiä esille, sekä millaisilla kysymyksillä näitä on ratkottu. Myöhemmässä kappaleessa on esitelty erilaisten työkalujen soveltuvuutta kysymyksiin vastaamisesta.
\subsection{Oikean aloituskohdan löytäminen}
Ohjelmointitehtävän alussa tehtävään liittyvien kohtien paikantaminen on haastavaa. Sillito, Murphy sekä De Volder havaitsivat artikkelissaan \cite{questions-during-software-evolution-tasks} havaitsivat ohjelmoijien käyttävän runsaasti aikaa sopivan aloituskohdan löytämiseen. Osan he havaitsivat aloittavan oleellisten koodin kohtien etsimisen tekstipohjaisella haulla, kun taas toiset käyttivät ohjelmointiympäristön kehittyneempää tyyppi -pohjaista hakua. Myös luokka ja paketti selaimia käytetään sopivan aloituskohdan löytämiseen. Tämä olettaa kuitenkin luokkien ja pakettien nimien olevan kuvaavia. Löydettässä mahdollisesti oleellisia kohtia, tulee ohjelmoijan voida tunnistaa, liittyyko löydetty kohta oleellisesti työnalla olevaan tehtävään. Eräs tapa tunnistaa koodin oleellisuus on käyttää debuggeria, asettaen mahdollisesti oleelliseen kohtaan pysähdyskohta (breakpoint) ja suorittamalla ohjelmaa debuggerin kautta voi huomata pysähtyykö ohjelma odotetusti pysähdyskohtiin. Myös selvittämällä mahdollisesti oleellisen kohdan riippuvuuksia muihin tyyppeihin, saa paremman vaikutelman siitä, onko kyseinen kohta oleellinen työn aloitukseen.

\subsection{Riippuvuuksien hahmottaminen}
Sopivan aloituskohdan ollessa selvillä, usein \cite{questions-during-software-evolution-tasks} seuraava askel riippuvuuksien hahmoittaminen. Tässä ohjelmoija tarkastelee itse oleellisia luokkia, mitä ne perivät, mitä rajapintoja ne toteuttavat sekä mitä metodeja luokka toteuttaa. Tarkastelu etenee hitaasti laajemalle alueelle, mitä tyyppejä oleellisessa kodassa käytetään ja miten ne liittyvät tähän luokkaan. Näin he mallintavat selkeiden riippuvuuksien ja oleellisten kohtien välisiä suhteita hahmoittaakseen paremmin, kuinka ohjelman oleellinen osa toimii.
Näihin kysymyksiin ohjelmoijat voivat helposti vastata käyttäen ohjelmointiympäristön perus työkaluja.

\subsection{Koodin konseptien selvittämnen}
Alkupaikan sekä läheisten riippuvuuksien selvittäminen on hyvä alku; kuitenkin usein on tarpeen saada selville tarkempi kokonaiskuva ohjelmiton oleellisesta osasta ja siten parantaa yleiskuvaa ohjelmiston toiminnasta. Tämän selvittämiseksi haetaan usein vastauksia kysymyksiin, missä tämä olio luodaan, mitä parametrejä sille annetaan, miten oikeaoppisesti käytetään tiettyä tietorakennetta sekä miten ohjelma käsittelee tietyt tapaukset \cite{questions-during-software-evolution-tasks}.


He havaitsivat, että useasti vastatakseen korkeamman tason kysymykseen, kysyjä kysyi useampia tukikysymyksiä saadakseen vastauksen korkean tason kysymykseen. Useasti tukikysymykset johtivat väärään vastaukseen, ja tutkittavien tuli palata kysymyksissään taaksepäin ja tarkentaa kysymyksiään eri suuntaan.


Sillito, Murphy ja De Volder selvittivät \cite{questions-during-software-evolution-tasks} millaisia kysymyksiä ohjelmakoodin muutostöis
Niin uutta ohjelmaa luotaessa, uutta ominaisuutta ohjelmistoon lisättäessä, ohjelmakoodia refaktoroitaessa k
Eli new dev
uudet featuret
security syyt
\section{What and why they ask?}

Sillito, Murphy ja De Volder selvittivät  \cite{questions-during-software-evolution-tasks} millaisia kysymyksiä ohjelmistokehittäjät kysyvät työskennellessään ohjelmistokoodimuutosten parissa.
He järjestivät kaksi tapaustutkimusta. Tutkimuksen, jossa ohjelmistokehittät työskentelivät pareina toteuttaenpyydetyn muutoksen heille aiemmin tuntemattomaan ohjelmakoodiin. Tähän heillä oli aikaa 45 minuuttia; tehtävässä tarkoituksena ei ollut saada pyydettyä tehtävää valmiiksi, vaan tehtävän odotettiin jäävän kesken. Pareista aina kokemattomampi oli ohjeistettu olemaan näppäimistöllä, ja kokeneempi tarkkailemaan vierestä. Näin he pyrkivät saamaan luonnollisempaa keskustelua aikaan.

Toisessa tapaustutkimuksessaan ohjelmistokehittäjät työskentelivät itselleen tutun ohjelmistokoodin parissa. Tässä heitä pyydettiin tekemään heille tyypillinen ohjelmointitehtävä.

Näistä tapaustutkimusista kertätystä datasta he tunnistivat neljä yleistä katogoriaa, mihin kaikki tutkimuksen aikana kysytyt kysymykset jakautuivat.
Ensimmäisten tehtävänantoon liittyvien kohtien löytäminen ohjelmakoodista, missä tiettyä tyyppiä/metodia käytetään ja missä ne sijaitsevat koodissa, koodiin liittyvien konseptien ymmärtäminen, kokonaiskuvan saavuttaminen ohjelman suorituksesta (omaan tehtävään liittyvästä osasta ainakin).
He havaitsivat, että useasti vastatakseen korkeamman tason kysymykseen, kysyjä kysyi useampia tukikysymyksiä saadakseen vastauksen korkean tason kysymykseen. Useasti tukikysymykset johtivat väärään vastaukseen, ja tutkittavien tuli palata kysymyksissään taaksepäin ja tarkentaa kysymyksiään eri suuntaan.

Tutkimuksessaan he selvittivät kysymysten lisäksi, mite erilaiset työkalut auttoivat vastaamaan kysymyksiin. He havainnoivat, että useasti kysymys oli liian avoin, jotta työkalut olisivat osanneet vastata niihin.
\section{asking and answering questions about unfamiliar apis}
AB ja C selvittivät artikkelissaan \cite{asking-and-answering-api-questions} millaisia kysymyksiä ohjelmistokehittäjät kysyvät kohdatessaan uuden ohjelmistorajapinnan (APIn).
Tapaustutkimuksessaan he tunnistivat kaikenkaikkiaan kaksikymmentä kysymystä, joista he tunnistivat viisi vaikeinta

Aluksi isoin kysymys uuden ohjelmistorajapinnan käytössä on, miten eri tyypit liittyvät toisiinsa.
He havaitsivat, että ohjelmistokehittäjillä oli toive, miten ohjelmistorajapinta toimisi, ja he ärsyyntyivät, kun ohjelmistorajapinta ei toiminutkaan odotetusti.
Usein kysymyksiin ei ollut helppoja vastauksia.
He havainnoivat, että erityisiä haasteita tutkittaville tuotti kahden tai useamman tyypin suhde.
Mitkä avainsanat kuvaavat ohjelmistorajapinnan toimintoja; erityisesti haettaessa lisätietoa ohjelmistorajapinnan käytöstä. Useilla oli vaikeuksia arvata aluksi avainsanoja oikein.
Miten luoda esiintymä tyypistä, ilman että sille on tarjolla julkista konstruktoria, miten selvittää metodikutsun tulos; metodin paluuarvon lisäksi heittääkö metodi poikkeuksia, ilmaisten että metodin suoritus päättyi virhetilanteeseen. Tässä he havaitsivat ohjelmistokehittäjien oletuksen metodin toiminnasta versus siitä, miten se oli toteutettu vaikuttavan paljon. Esimerkkinä he nostivat esille xml tiedoston validaatiometodin. Ohjelmistokehittäjät odottivat validaatio metodin palauttavan arvon joka kuvaa validaation onnistumista, kun taas todellisuudessa metodi ei palauta mitään kun xml tiedosto on validi, ja heittää poikkeuksen xml tiedoston ollessa epävalidi. Myös onnistuminen ja virhe oli ohjelmistokehittäjien ja ohjelmistorajapinnan luojien mielestä erilainen. Kävi myös ilmi, että tutkittavat kuvittelivat poikkeusten liittyvän paljon vakavempiin ongelmiin, kuin tiedoston epävalidiuuteen, eivätkä he siten olleet sisäistäneet poikkeuksien käyttötapoja.
He korostavat, että poikkeusten käyttäminen kaikkien virhetilanteiden esittämiseen vaikeuttaa ohjelmistorajapinnan sisäistämisen.
Eri hakutapojen vaikutus, he havaitsivat noin puolen tutkittavista hakeneen esimerkkejä ja dokumentaatiota webistä, kun taas loput käyttivät vain paikallista dokumentaatiota. Kävi ilmi, että tällä hakutapaerolla ei ollut kummepaa vaikutusta tehtävästä selviämisessä. He havaitsivat, että tutkittavat aliarvioivat koodiesimerkkien haun vievän ajan. Tosin useat tutkittavat eivät onnistuneet löytämään sopivia esimerkkejä ja lopulta tyytyivät paikalliseen dokumentaatioon.
Useat ohjelmointiympäristöjen työkalut koodin täydennyksessä yms, eivät tarjoa kunnollista tukea työhön liittyvien tyyppien tunnistamiseen, vaan olettavat, että ohjelmistokehittäjä tuntee jo tarvittavat tyypit.
Myös tyyppien ja objektien relaatioita tulisi tarkentaa dokumentaatiossa, erityisesti niissä tapauksissa, missä tietty tyyppinen olio voidaankin luoda vain kokoaan toisessa luokassa, eikä sillä ole julkista konstruktoria. Monet kokivat sen hämääväksi.


\section{Eliciting Design Requirements for Maintenance-Oriented IDEs: A Detailed Study of Corrective and Perfective Maintenance Tasks}
Artikkelissa \cite{eliciting-design-requirements-for-maintenance-oriented-ides}
Vaikka työkalujen määrä ohjelmistokehityksessä on kasvanut, suuri osa työkaluista on tehty kehitys-, ei ylläpitovaiheeseen. Tapaustutkimuksessa he keskittyvät viiden eri ylläpitotehtävän tekemiseen, tekiöinä kokeineita java ohjelmistokehittäjiä.
He jakavat ylläpito-operaation kolmeen vaiheeseen, relevanttien tiedostojen ja koodipalojen löytäminen, näiden välisten suhteiden mallintaminen ja toteutettavat muutokset.
Tutkimuksessa tutkittaville annettiin 7 käyttäjien virheraporttia, joista mahdollisimman moni kuvattu ongelma heidän tuli korjata tutkimuksen aikana. Tutkimus kesti 70 minuuttia.
Tutkimusessa käytetty koodivarasto koostui yhdeksästä java-tiedostusta.
Muutostyön alussa he havaitsivat tutkittavan usein kysyvän, kuinka X toimii ja miksi X ei tapautunut. Näiden pohjalta tutkittavat alkoivat tyypillisesti rajaamaan relevantteja koodipaloja.
Löydettyään tarpeellisen koodin he selvittivät sen suhteita toisiin luokkiin. He kysyivät tyypillisesti, mikä vaikuttaa muuttujan arvoon, mikä tämä muuttuja on.
Tehtävään liittyvien koodipalojen etsinnässä moni valitsi epäolennaisia paloja, ja he käyttivät huomattavasti aikaa epäolennaisen koodin tarkasteluun.

Aktiviteettejä tarkkailemalla, heille selvisi, että keskimäärin yhtä suuri osa ajasta menee koodin lukemiseen kuin koodin muokkaamiseen. kun taas koodin navigointiin ja esimerkkien hakuun käytettiin hieman vähemmän aikaa. Vähiten aikaa meni ohjelman testaukseen.
He tunnistivat seuraavat tarpeet muutos töihin tarkoitettuihin työkaluigin.
Workingset:in ylläpito, tehtävään oleellisten koodipalojen listaus, sekä näiden riippuvuuksien hallinta. Kopiointiin liittyvien virheiden korjaamiseksi he ehdoittivat kopionnin säilyvän koodin kontekstissa ja siten ohjelmointiympäristön korostavan, että kopioidussa koodissa voi olla vielä korjaamattomia virheitä.
He ehdottivay myös koodipaloista koostuvaa editoria, jossa tiedostosta on esillä vain tarpeellinen osa. Näin saisi helpommin kaikki oleelliset osat koodista esille.
Ympäristön tulisi visualisoida ohjelmakoodin riippuvuudet. Sen sijaan että ohjelmoija navigoi ja katsoo jokaista riippuvuutta erikseen, voisi ohjelmointiympäristö tarjota selkeämmän tavan nopeammin tarkastella riippuvuuksia.
Vastatessaan alun kysymyksiinsä, miksi ja miten ohjelmistokehittäjät joutuvat tutkimuksen mukaan usein arvaamaan ja tekevät merkittäviä johtopäätöksiä ohjelmiston toiminnasta. Ohjelmistoympäristön pitäisi osata vastata kysymyksiin miksi ja miten. % helppoa :D

\section{Tyypillisiä ongelmia}
Tiivistä ylhäältä
APIt on vaikeita
  Jungloid mining

\section{Työkaluja avun hakuun}
\subsection{Grep}
\subsection{IDE}

%esimerkkejä
\subsection{Stackoverflow}
\subsection{Javadoc}
\subsection{OSS - Github}
\subsection{Blogit}


\bibliographystyle{babplain-lf}
\bibliography{../lahteet}

\end{document}
