\documentclass[finnish]{tktltiki2}
% Remove widow and orphan lines
\clubpenalty=10000
\widowpenalty=10000

% Remove hyphenation
\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=1000000
\hbadness=1000000


% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
%
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{setspace}
\onehalfspacing

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

%\title{Ongelmat ohjelmointiprosessissa ja niiden ratkaiseminen}
\title{Ohjelmointitehtävän aloittaminen ja siinä hyödynnettävät työkalut}
\author{Jarmo Isotalo}
\date{\today}
\level{Kandidaatintutkielma}
\abstract
{Ohjelmistoihin joudutaan virhetilanteiden ja uusien ominaisuuksien lisäysten takia tekemään muutoksia. Usein muutoksen tai korjauksen tekee ohjelmoija, joka ei alunperin ole ollut tuottamassa kyseistä ohjelmakoodia. Ohjelmoijan tulee selvittää järjestelmän toimintaa, jotta hän pääsisi nopeasti tekemään halutun muutoksen.

Ohjelmoijan tueksi on kehitetty useita erilaisia työkaluja ja ohjelmistoja, mutta moni ei osaa käyttää näitä työkaluja täysimääräisesti eikä tehokkaasti osana omaa ohjelmointiprosessiaan. Kaikki työkalut eivät sovi kaikkiin tilanteisiin, joten on tärkeää tuntea eri työkalujen toiminnallisuudet. Tutustumalla välineisiin ja opettelemalla työkalujen käyttöä ohjelmoijan on mahdollista suorittaa ohjelmointitehtävät entistä tehokkaammin.

Tässä tutkielmassa esittelen uusien ohjelmointitehtävien aloittamisen etenemistä, jossa ohjelmoija selvittää ohjelman rakennetta ja toimintaa itselleen. Ohjelmointitehtävän aloittamisessa ohjelmoijan tulee priorisoida tehtävät, etsiä sopiva aloituskohta, hahmottaa ohjelman riippuvuudet, selvittää koodin rakenne ja tutustua käytettyihin ohjelmointirajapintoihin. Lisäksi esittelen työn tueksi tehtyjä työkaluja ja käyn läpi millaisia sosiaalisen median palveluita on ohjelmoijien avuksi.
}

% The following can be used to specify keywords and classification of the paper:

\keywords{ohjelmistotuotanto, ohjelmointitehtävä, virheen etsintä, virheen korjaus, muutostenteko, työkalut}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title

% "ACM Computing Classification System (CCS):"
% CCS →  Social and professional topics →  Professional topics →  Computing profession →  Assistive technologies

\classification{D.2.1 [Software Engineering]: Tools
\\D.2.2 [Software Engineering]: Programmer workbench }

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
%\faculty{Matemaattis-luonnontieteellinen}
%\department{Tietojenkäsittelytieteen laitos}
%\subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
%\university{Helsingin Yliopisto}
%\universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
%\city{Helsinki}


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}

Ohjelmistot ovat keskeisessä asemassa ihmisen elämässä ja liiketoiminnassa. Ihmisten arki on muuttunut älypuhelinten ja tablettien yleistyttyä ja niissä toimivia sovelluksia käytetään yhä enemmän. Harva liiketoiminta on mahdollista ilman tietojärjestelmiä ja esimerkiksi sähkökatkon sattuessa usean yrityksen toiminta vaiheutuu tai jopa estyy kokonaan.

Tietojärjestelmissä olevat virheet haittaavat liiketoimintaa ja ihmisten elämää. Järjestelmiin päätyvien virheiden syntymistä pyritään estämään ohjelmiston kehitysprosessin eri vaiheissa erilaisin menetelmin. Määrittelydokumenttien katselmointi on hyväksi havaittu keino estämään tilannetta, jossa ohjelmoija ohjelmoi virheettömän toiminnon, mutta toiminto ei vastaa loppukäyttäjän tarvetta. Ohjelmakoodiin päätyviä virheitä pyritään välttämään muun muassa pariohjelmoinnilla ja koodianalyyseillä.

Testauksella pyritään ehkäisemään koodiin muutoksen yhteydessä syntyviä sivuvaikutuksia, mutta erityisesti monimutkaisissa ja laajoissa ohjelmistokokonaisuuksissa on mahdotonta tunnistaa kaikki virhetilanteet. Muiden käyttöön tarkoitettujen kirjastojen kohdalla mahdollisten sivuvaikutusten riski kasvaa, mikäli muutos koodiin muuttaa ohjelman toimintaa tai korjaa pitkäaikaisen virheen. Kaikista toimista huolimatta sovelluksia ei kuitenkaan saada täysin virheettömiksi, sillä kattavaan virheiden etsintään ei ole aina varaa.

Virhekorjausten lisäksi ohjelmistoja muutetaan tekemällä niihin
\begin{itemize}
  \item teknisiä parannuksia esimerkiksi suorituskyvyn tai ylläpidettävyyden parantamiseksi
  \item käyttöliittymämuutoksia käyttäjäkokemuksen parantamiseksi tai
  \item ohjelmoimalla niihin uusia toiminnallisuuksia.
\end{itemize}
Paitsi järjestelmissä olevat ohjelmointivirheet myös järjestelmien tekniseen ylläpitoon liittyvät ongelmatilanteet saavat helposti liiketoiminnan ja ihmisen arjen sekaisin. Hiljattain Facebook oli jonkun aikaa pois käytöstä ja ihmiset soittivat hädissään hätäkeskukseen~\cite{facebook-down}.

IT-alalla kaikille on tuttu sanonta: ``Jos se toimii, älä koske siihen'', sillä jos ohjelmistokokonaisuutta ja siinä käytettyä logiikkaa ei tunne, saattaa ohjelmakoodin saada sekaisin tekemällä pieneltä tuntuvan muutoksen: muutos itsessään on virheetön, mutta se aiheuttaa ennalta arvaamattomia sivuvaikutuksia muualle koodiin.

%Erilaisista, yllämainituista syistä johtuen tuotantokäytössä oleviin järjestelmiin joudutaan usein tekemään korjauksia tai täydennyksiä ja tuon työn tekee ohjelmoija.

Jos alkuperäisen koodin tehnyt ohjelmoija on edelleen käytettävissä, hän kykenee varsin nopeasti aloittamaan haluttujen muutosten tekemisen, koska koodi, käytetty logiikka ja ohjelman rakenne ovat hänelle entuudestaan tuttuja. Usein kuitenkin käy niin, että muutoksen joutuu tekemään henkilö, jolle koko ohjelmisto on täysin tuntematon.
Korjausten ja täydennysten tekemisen tulee olla mahdollisimman tehokasta, jotteivat korjauskulut kasva kohtuuttomiksi ja jotta häiriön vaikutus loppukäyttäjille olisi mahdollisimman lyhyt.

Tutkimuksen mukaan ohjelmoijat käyttävät jopa 80 \% ajastaan testaamiseen ja virheiden jäljitykseen~\cite{debugging-is-expensive}.
Tehokas prosessi edellyttää sitä, että ohjelmoija pääsee tekemään aitoa lisäarvoa tuottavaa työtä korjauksen tai uuden ominaisuuden ohjelmoinnin myötä sen sijaan, että aikaa menee korjaus- tai lisäyskohdan etsimiseen.

Ohjelmoijan työn helpottamiseksi on luotu useita työkaluja ja sosiaalisia medioita, joista löytyy apua ongelman ratkaisuun, mutta valitettavasti kaikki ohjelmoijat eivät tunne niitä riittävästi tai he eivät osaa hyödyntää niitä omassa prosessissaan täysimääräisesti. Tutustumalla välineisiin ja opettelemalla niiden käyttöä ohjelmoijan on mahdollista suorittaa ohjelmointitehtävät entistä tehokkaammin. Kaikki välineet eivät sovi kaikkiin tilanteisiin, joten on tärkeää tuntea eri välineiden toiminnallisuudet.

Tutkielman rakenne muodostuu seuraavasti: alussa tarkastelen uuden ohjelmointitehtävän aloittamiseen liittyviä tehtäväkokonaisuuksia, joiden avulla ohjelmoija muodostaa itselleen yleiskuvan ohjelmasta pystyäkseen ratkaisemaan hänelle annetun ohjelmointitehtävän. Sen jälkeen tarkastelen muutamia ohjelmointitehtävän aloittamisen tueksi suunnattuja työkaluja ja ohjelmistoja sekä lopuksi kerron, kuinka ohjelmoija voi löytää sosiaalisesta mediasta vastauksia kysymyksiinsä ja apua tehtävän suorittamiseen.

\subsection{Tutkimusmenetelmä}

Tässä tutkielmassa käytettiin aineiston valinnassa
\begin{enumerate}
  \item harkinnanvaraista otantaa ja
  \item lumipallotekniikkaa.
\end{enumerate}

Harkinnanvarainen otanta ja aineistolähtöisyys ovat keskeisiä tekijöitä laadullisessa tutkimuksessa~\cite[s. 16-20]{laadullinen-tutkimus-ja-sisallonanalyysi}.
Harkinnanvaraisella otannalla tarkoitetaan sitä, että aineisto valitaan tutkijan asettamien kriteereiden perusteella~\cite{aineiston-maara-ja-tutkittavat}.

Tuomi ja Sarajärvi kuvaavat aineistonhankintamenetelmänä lumipallotekniikkaa, jossa aineiston hankinnan alkuvaiheessa tiedetään tietolähde, joka johdattaa tutkijan toisen tietolähteen pariin. Aineiston hankinta etenee siten, että tutkija etenee tiedonantajasta toiseen sitä mukaa, kun hän löytää uusia tietolähteitä~\cite[s. 88]{johdatus-laadulliseen-tutkimukseen}. Lumipallo-termi tulee siitä, että otos kertyy kuin pyörivä lumipallo, kasvaen kierros kierrokselta.

Tutkimuskysymykset vaikuttavat luonnollisesti tutkittavan aineiston määrään ja luonteeseen. Lähdeaineistoja etsin Google Scholarista sekä ACM Digital Librarystä.

Oli haastavaa löytää oikeat avainsanat etsiessäni lähtöartikkeleita tutkielmaani. Tein lukuisia hakuja käyttämällä erityyppisiä yhdistelmiä sanoista ohjelmisto, virheenkorjaus, virheentunnistus, virhe, järjestelmäkehitys, ohjelmistokehitys, työkalut ja virheenetsintä niiden englanninkielisillä käännöksillä. Tutustuin kunkin haun tuloksena löytyneen artikkelin otsikkoon, tiivistelmään, viitteisiin (reference) sekä viittauksiin (cited by). Valitsin työni lähtöartikkeleiksi harkinnanvaraisella otoksella arvioni perusteella tutkimuskysymyksiini parhaiten sopivat artikkelit, jotka ovat:

\begin{enumerate}
  \item How Developers Search for Code: A Case Study~\cite{g_search_code}
  \item Specifying What to Search for~\cite{what-to-search-for}
\end{enumerate}
Valittuani lähtöartikkelit etenin aineiston valinnassa lumipallotekniikalla
käyden läpi lähdeartikkelien viitteet ja viittaukset sekä näiden artikkelien viitteet ja viittaukset arvioiden artikkelin oleellisuutta tutkielmassani otsikon ja tiivistelmän perusteella. Hakuavaruuden kasvettua noin kahteensataan artikkeliin lopetin määrätietoisen hakuavaruuden laajentamisen ja keskityin pienentämään hakuavaruutta karsimalla mahdollisesti oleellisten artikkelien joukkoa artikkelien otsikon, tiivistelmän ja ensimmäisten kappaleiden perusteella. Näin sain valittua hakuavaruudesta noin 15 varmasti tutkielmaan sopivaa artikkelia.  Kirjallisuuskatsauksen edetessä lähdeaineistoon nousi mukaan muutama aiemmassa karsinnassa hylätty, mutta valituissa artikkeleissa kiinnostavasti viitattu artikkeli.

Tutkimuksen edetessä löytyi muutamia uusia kiinnostavia ja tutkimusta tukevia lähdeaineistoja, jotka eivät olleet löytyneet alkuperäisessä haussa. Lisäksi lähdeaineistossa on laadullista tutkimusta valottavia teoksia.

\subsection{Tutkimuskysymykset}

Asetin tutkielmani tutkimuskysymykset seuraavasti:

\begin{enumerate}
  \item Miten ohjelmoijien kannattaa aloittaa uusi ohjelmointitehtävä.
  \item Mitä työkaluja ohjelmointitehtävän aloittamisen tueksi on.
  \item Miten sosiaalista mediaa voidaan hyödyntää ohjelmistoprosessin aikana.
\end{enumerate}
Ensimmäiseen tutkimuskysymykseen vastaan luvussa~\ref{section:ekatk}, jossa käyn läpi uuden ohjelmointitehtävän aloittamisen vaiheet: ohjelmointitehtävän valinta, sopivan aloituskohdan löytäminen, riippuvuuksien hahmottaminen, koodin rakenteen selvittäminen ja ohjelmointirajapinnan tutustuminen.
Toiseen tutkimuskysymykseen vastaan luvussa~\ref{section:tokatk}, jossa esittelen ohjelmoijan tueksi tehtyjä työkaluja ja kuvaan niiden käyttötarkoitusta ja vahvuuksia sekä heikkouksia.
Kolmanteen tutkimuskysymykseen vastaan luvussa~\ref{section:kolmastk}, jossa esittelen erilaisia ohjelmoijille suunnattuja sosiaalisen median palveluita ja kerron niiden hyödyntämisestä ohjelmointitehtävää suoritettaessa.

\section{Uuden ohjelmointitehtävän aloittaminen}
\label{section:ekatk}

Vaikka ohjelmoijan käytössä olisi tekninen dokumentaatio, se ei välttämättä yksin riitä ohjelmointitehtävän aloittamisen tueksi. Dokumentaation lukemisen lisäksi ohjelmoija ryhtyy yleensä selvittämään ohjelmiston rakennetta esittämällä itselleen erilaisia loogisia kysymyksiä ohjelmakoodin toiminnasta ja toimimattomuudesta. Kysymyksillä pyritään luomaan kuvaa siitä, miten ohjelma toimii ja mistä osista se rakentuu \cite{g_search_code, questions-during-software-evolution-tasks,asking-and-answering-api-questions}. Usein ongelmaa ratkaistaessa tulee esiin uusia kysymykseen liittyviä, alkuperäistä kysymystä tarkentavia kysymyksiä, joihin vastaaminen lopulta edesauttaa alkuperäiseen kysymykseen vastaamista~\cite{questions-during-software-evolution-tasks}. Näihin kysymyksiin vastaaminen ei ole aina helppoa saati nopeaa: vastausten löytymiseen saattaa kulua jopa puolet ohjelmointiin käytetystä ajasta~\cite{eliciting-design-requirements-for-maintenance-oriented-ides}.

Selvitystyötä tehdään erityisesti silloin, kun ohjelmoija työskentelee uuden ominaisuuden tai muutostyön parissa tai kun työstettävä ohjelmakoodi on ohjelmoijalle tuntematonta. Ohjelmoija ei voi tehdä tehokkaasti haluttua muutosta perehtymättä ensin riittävässä määrin ohjelmakoodin toimintaan.

Tarkastelen ohjelmointitehtävän aloittamisen etenemistä, jonka mukaisesti ohjelmoija etenee tehdessään muutoksia ohjelmakoodiin. Hänen tulee ensin priorisoida tehtävät, etsiä sopiva aloituskohta, hahmottaa ohjelman riippuvuudet, selvittää koodin rakenne ja tutustua ohjelmointirajapintoihin. Sen jälkeen tarkastelen muutamia työn tueksi tarkoitettuja työkaluja sekä ohjelmistoja ja sosiaalisen median käyttöä. Tarkastelussa mukailen artikkeleissa Eliciting Design Requirements for Maintenance-oriented IDEs: A Detailed Study of Corrective and Perfective Maintenance Tasks~\cite{eliciting-design-requirements-for-maintenance-oriented-ides} ja Questions Programmers Ask During Software Evolution Tasks~\cite{questions-during-software-evolution-tasks} käytettyä, hyväksi kokemaani, rakennetta.

\subsection{Ohjelmointitehtävän valinta}

% Tylsä lähde, mutta oikeestaan en löytänyt mitään super luotettavaa lähdettä... vaikka moni sivu tuki tätä lajittelua
Ohjelmoijalla on usein työlistalla useita virhekorjauksia, jotka hänen täytyy laittaa tärkeysjärjestykseen, koska kaikki ohjelmistossa olevat virheet eivät ole samanarvoisia.
Jenkins suosittelee luokittelemaan virheet kiireellisyyden mukaan kolmeen luokkaan~\cite{testing-primer}:
\begin{description}
  \item[Korkea] \hfill \\
  Vaatii välittömän korjauksen. Ohittaa kaikki muut jonossa olevat työt. Tällainen virhe estää järjestelmän käytön tai vaikeuttaa sitä huomattavasti.
  \item[Normaali] \hfill \\
  Korjaus kannattaa tehdä pian. Tällainen virhe vaikeuttaa järjestelmän käyttöä, estämättä sitä kokonaan. Virhe on usein kierrettävissä.
  \item[Alhainen] \hfill \\
  Korjauksella ei ole kiire. Tällainen virhe on esimerkiksi kosmeettinen haitta.
\end{description}
Korjauksen kiireellisyyteen vaikuttavat virheen luokittelun lisäksi virheen laajuus, eli moneenko käyttäjään virhe vaikuttaa.


%Lönnroth ja Törmälä luokittelevat virheet neljään luokkaan~\cite{testaus-kriittisyys}:
%\begin{enumerate}
%  \item Kriittinen virhe, joka estää järjestelmän käytön.
%  \item Virhe, joka vaikeuttaa järjestelmän käyttöä.
%  \item Virhe, joka voidaan ohittaa tekemällä toiminto tilapäisesti eri tavalla.
%  \item Kosmeettinen haitta, joka ei estä järjestelmän käyttöä.
%\end{enumerate}


%\begin{description}
%  \item[Välitön] \hfill \\
%  Vaatii välittömän korjauksen. Ohittaa kaikki muut jonossa olevat työt.
%  \item[Kiireellinen] \hfill \\
%  Korjaus on tehtävä viikon kuluessa.
%  \item[Normaali] \hfill \\
%  Korjaus voi odottaa seuraavaa versiota.
%  \item[Alhainen] \hfill \\
%  Korjauksella ei ole kiire.
%\end{description}

\subsection{Ohjelmointitehtävän aloituskohdan löytäminen}

Uuden ohjelmointitehtävän aloittaminen on usein haastavaa~\cite{questions-during-software-evolution-tasks}, vaikka tiedossa olisi suurinpiirtein se toiminnallisuus tai korjaus, joka on tarkoitus tehdä. Tilanne on sama, oli sitten kyseessä olemassaolevan ohjelmiston toimintavirheen korjaaminen tai uuden ominaisuuden lisääminen ohjelmaan. Erityisen haastavaksi aloittamisen tekee se, jos ohjelman koodi ei ole ohjelmoijalle tuttua. Tällöin ennen tehtävän aloittamista ohjelmoijan tulee selvittää ohjelman rakennetta ja toimintaa sekä selvittää, mitkä ovat oleellisia kohtia tehtävän muutoksen kannalta.

Eräs tapa aloituskohdan löytämiseen on arvata sopivia aiheeseen liittyviä avainsanoja, joiden perusteella voi hakea kohtia ohjelmakoodista. Koska oikeiden avainsanojen keksiminen~\cite{what-to-search-for} on vaikeaa, on haasteena epäoleellisten tulosten suuri määrä, mikä hidastaa prosessia entisestään. Haku saattaa joskus johdatella kokonaan väärään suuntaan hidastaen entisestään oleellisen kohdan paikantamista.

Toinen tapa sopivan aloituskohdan löytämiseen ovat ohjelmistoympäristöjen tarjoamat luokka- ja pakkauskaaviotyökalut. Kaikki ohjelmoijat eivät kuitenkaan osaa tehokkaasti käyttää tarjolla olevia luokka- ja pakkauskaaviotyökaluja.

Myös virheenjäljitintä (debugger) voidaan käyttää sopivaksi arvellun aloituskohdan paikantamiseen merkitsemällä ohjelmakoodiin pysähdyskohtia (break point) sellaisiin kohtiin, joiden ohjelmoija arvioi olevan oleellisia.
Seuraamalla ohjelman suoritusta virheenjäljittimellä näkee helposti, pysähtyykö ohjelman suoritus merkittyihin pysähdyskohtiin eli eteneekö koodin logiikka ohjelmoijan ajattelemalla tavalla~\cite{eliciting-design-requirements-for-maintenance-oriented-ides}.
Tässäkin, kuten aiemmassakin aloituskohtien paikantamiseen käytetyissä tavoissa, on haasteena sopivien pysähdyskohtien löytäminen~\cite{eliciting-design-requirements-for-maintenance-oriented-ides}.
% emt toi on tylsä TODO
Virheenjäljittimen käyttö on tutkimuksen mukaan hidasta ja siten se on yksi kalleimmista ohjelmoijan käyttämistä työkaluista~\cite{debugging-is-expensive}.


Haasteeksi kaikissa edellä mainituissa tavoissa muodostuu suhteellisen suuri määrä täysin epäolennaisia tuloksia~\cite{eliciting-design-requirements-for-maintenance-oriented-ides}, jotka vievät ohjelmoijan aikaa ja saattavat pahimmillaan johdatella ohjelmoijan pitkäksi aikaa tarkastelemaan väärää aluetta ohjelmakoodista ennen kuin kohdan epäolennaisuus selviää hänelle.

\subsection{Riippuvuuksien hahmottaminen}
Kun sopiva aloituskohta on tiedossa, voi ohjelmoija keskittyä tarkastelemaan kyseistä ohjelmakoodin kohtaa, sen suhdetta ja riippuvuuksia muuhun ohjelmakoodiin~\cite{questions-during-software-evolution-tasks}.

Tarkastelemalla aloituskohdan ohjelmakoodissa olevia luokkia ja niiden suhdetta muuhun ohjelmakoodiin, kuitenkin aluksi keskittyen läheisiin luokkiin, niiden rakenteisiin ja metodeihin, on tarkoitus pyrkiä parantamaan ohjelmoijan omaa käsitystä oleellisesta ohjelmakoodista. Tässä tyypillisesti tarkastellaan, mitä tietorakenteita ja luokkia oleellisessa ohjelmakoodin kohdassa käytetään sekä mitä metodeja on luokassa, jossa oleellinen kohta sijaitsee. Lisäksi tarkastellaan myös luokan perimää sekä sen toteuttamia rajapintoja keskittyen tarkastelussa vain lähimpien luokkien tarkasteluun, jolloin muodostetaan tarkka yleiskuva pieneltä alueelta~\cite{questions-during-software-evolution-tasks,questions-during-software-evolution-tasks}.
Useat ohjelmointiympäristöt tukevat yllämainittua hyvin tarjoamalla helpon navigoinnin luokkien ja niiden riippuvuuksien välillä. Myös ohjelmointiympäristöjen tarjoamat luokka- ja pakettitason tarkasteluun tarkoitetut työkalut auttavat ohjelmoijaa riippuvuuksien hahmottamisessa.

\subsection{Koodin rakenteen selvittäminen}
Kun oleellisen aloituskohdan läheiset riippuvuudet ovat selvillä, on seuraava askel tarkastella koodin rakennetta. Samalla muodostetaan kokonaiskuva ohjelmiston toiminnasta tarkastellen sitä, missä oleellisen aloituskohdan sisältävä esiintymä luokasta luodaan ja mitä parametrejä sille annetaan. Lisäksi tarkastellaan sitä, missä oleellisen kohdan luokkaa ja sen esiintymiä käytetään sekä mitkä kapseloivat kyseisiä esiintymiä ja mihin niitä käytetään~\cite{questions-during-software-evolution-tasks}.

Ohjelmointiympäristöistä on tässä apua. Useat ohjelmointiympäristöt tarjoavat mahdollisuuden hakea ohjelmakoodista kohtia, mistä metodia kutsutaan sekä kohtia, missä tiettyä tyyppiä (Type) käytetään. Nämä auttavat selvittämään kyseisen kohdan käytön laajuutta ja paikkoja ohjelmakoodissa.

% POIS: TODO KEKSI VIITE Aloittelijoille tavanomainen, mutta ei kovin hyvä, tapa vastaavaan selvitykseen on esimerkiksi muuttaa metodin määrittelyä (signature) siten, että metodia ei enää löydy. Tämän jälkeen kääntämällä ohjelmakoodin uudestaan voi nähdä kaikki kyseistä metodia käyttävät kohdat, sillä kääntäjä raportoi käännösvirheestä niissä kohdissa, jotka käyttivät kyseistä metodia. Vastaavasti luokan nimeä muuttamalla ja sen jälkeen ohjelmankoodin kääntämällä ja virheitä tarkastelemalla saa selville, missä luokkaa on käytetty. Tämä ei ole suositeltu tapa, mutta se on kuitenkin aloittelijoiden keskuudessa tyypillinen.

\subsection{Ohjelmointirajapintoihin tutustuminen}
Niin ohjelman toimintaa tarkastellessa kuin uutta ominaisuutta luodessa tulee useasti vastaan ennalta tuntemattomia ohjelmointirajapintoja (API, Application Programming Interface).
Joskus ohjelmointirajapinnat ovat helppokäyttöisiä, mutta varsinkin isompien ohjelmistojen kohdalla ne ovat monipuolisia ja siten vaikeammin sisäistettävissä.

Yksi tapa tutustua ohjelmointirajapinnan käyttöön on etsiä omaan käyttötarkoitukseen sopivia esimerkkejä kyseisen ohjelmointirajapinnan käytöstä. Tällöin haasteeksi muodostuu esimerkkien suuri määrä ja niiden vaihteleva laatu~\cite{example-overflow-social-media-for-code-recommendations}. Käytössä olevasta ohjelmointirajapinnasta riippuen hyvien esimerkkien löytäminen on hyvin haastavaa, ja ohjelmoijat, jotka hakevat esimerkkejä, päätyvät usein palaamaan ohjelmointirajapinnan dokumentaatioon~\cite{asking-and-answering-api-questions}. Tämä kuitenkin riippuu pitkälti käytössä olevasta ohjelmointirajapinnasta sekä siitä, miten tavanomaista asiaa sillä on tekemässä. Esittelen kappaleessa~\ref{ch:exampleoverflow} ExampleOverflow'n~\cite{example-overflow-social-media-for-code-recommendations}, joka pyrkii tekemään esimerkkien etsimisestä helpompaa.

Uuteen ohjelmointirajapintaan tutustuminen aloitetaan usein varmistamalla ensin, että kyseinen ohjelmointirajapinta varmasti tarjoaa tarkoitukseen sopivan toiminnallisuuden. Tämän jälkeen voidaan aloittaa tarkempi tutustuminen ohjelmointirajapintaan.

Vastaavasti, kuten uuteen ohjelmistoon tutustuttaessa, pyritään aluksi paikantamaan ne luokat ja metodit, jotka ovat tarpeen. Niiden löydyttyä ryhdytään selvittämään löydettyjen luokkien ja metodien suhteita muihin ohjelmointirajapinnan käyttämiin tyyppeihin. Myös dokumentaation lukeminen auttaa, mutta se harvoin tarjoaa riittävää yleiskuvaa siitä, mihin luokka yleiskuvassa asettuu tai minkä muiden luokkien kanssa sitä tyypillisesti käytetään~\cite{asking-and-answering-api-questions}.

Ohjelmointiympäristöt tarjoavat heikosti apua uusien ohjelmointirajapintojen käytöönotossa~\cite{jungloid-mining}. Ohjelmistoympäristöt tarjoavat automaattista täydennystä vasta silloin, kun ohjelmoija tietää, mitä luokkia ja rajapintoja tarvitaan ja on mahdollisesti käynyt itse lisäämässä käytetyt riippuvuudet projektiin. Useimmiten ohjelmointirajapinnan käytön sisäistämiseen käytetään vain ohjelmointirajapinnan tarjoamaa sisäistä dokumentaatiota, mikä harvoin auttaa kattavan yleiskuvan luomisessa ohjelmointirajapinnasta. Myös tästä dokumentaatiosta oleellisien kohtien löytäminen on vaikeaa, sillä sopivan avainsanan keksiminen on useasti haastavaa~\cite{what-to-search-for}.

% Toinen tapa tutustua ohjelmointirajapinnan käyttöön on etsiä omaan käyttötarkoitukseen sopivia esimerkkejä kyseisen ohjelmointirajapinnan käytöstä. Esittelen kappaleessa~\ref{ch:exampleoverflow} ExampleOverflow'n~\cite{example-overflow-social-media-for-code-recommendations}, joka pyrkii tekemään esimerkkien etsimisestä helpompaa.

\section{Työkaluja ohjelmointitehtävän tueksi}
\label{section:tokatk}
Ohjelmoijalla on käytössään ohjelmointiympäristö (IDE, Integrated Development Environment), kts. NetBeans\footnote{\url{https://netbeans.org}}. Ohjelmoijien tueksi on myös luotu muita työkaluja ja apuvälineitä auttamaan ohjelmointitehtävässä kohdattujen ongelmien ratkaisussa.
Yksi haasteista on sopivan työkalun valinta kulloinkin kyseessä olevaan tehtävään: kaikki ohjelmoijan avuksi tehdyt työkalut eivät osaa auttaa kaikissa ongelmissa. Toinen haaste on se, että vaikka ohjelmoija valitsee sopivan työkalun, käyttää hän todennäköisesti vain osaa tarkoitukseen luoduista ominaisuuksista~\cite{whyline}.

Alla esittelen tyypillisiä ohjelmoijan elämän helpottamiseksi luotuja työkaluja. Osa työkaluista on tarkoitettu auttamaan yleisellä tasolla, kun taas toiset auttavat vain pienessä, mutta sitäkin haastavammassa osassa.
%Joitakin työkaluja voi hyödyntää, vaikkei niitä alunperin ole tehty siihen tarkoitukseen.

\subsection{Ohjelmointiympäristö}
Ohjelmointiympäristö on ohjelmisto, joka pyrkii tukemaan ohjelmoijan arkea tarjoamalla kaikki olennaisimmat työkalut ohjelmiston kehittämiseen~\cite{eclipse-ide}. Ohjelmointiympäristö koostuu tyypillisesti tekstieditorista, joka tukee ohjelmakoodin syntaksiväritystä sekä ohjelmakoodin kirjoittamista tarjoamalla automaattista koodin täydennystä kielen standardikirjaston ja jo käytettyjen kirjastojen perusteella.

Ohjelmointiympäristö tarjoaa myös joko hyvän integraation ulkoiseen kääntäjään tai sisäänrakennetun kääntäjän, jonka avulla editori kertoo ohjelmoijalle ohjelmakoodin syntaksivirheistä ohjelmakoodia kirjoitettaessa.

Näin ohjelmoija tunnistaa ja pystyy korjaamaan syntaksivirheet heti virheen havaittuaan. Erillistä aikaa vievää käännösaskelta usein myöskään tarvita, sillä ohjelmointiympäristö kääntää usein ohjelmakoodin sitä tahtia kuin sitä kirjoitetaan. Tämä säästää ohjelmoijan aikaa.

Ohjelmointiympäristöt eivät kuitenkaan ratkaise kaikkia ohjelmoijien ongelmia. Vaikka ohjelmointiympäristöt ovat usein erikoistuneet vain muutamiin kieliin, tarjoavat ne usein jonkinasteisen tuen hyvin monille muille kielille. Riippuen käytetystä ohjelmointiympäristöstä ja kielestä ohjelmointiympäristön ohjelmoijalle tarjoavat ominaisuudet saattavat siis olla erilaiset.

Useissa ohjelmointiympäristöissä on myös sisäänrakennettu virheenetsin kielille, joiden kirjoittamiseen ohjelmointiympäristö on erikoistunut. Se avustaa ohjelmakoodin suorituksen tarkastelun lause lauseelta. Ohjelmointiympäristöt tarjoavat myös tiedostoselaimen projektin tiedostoille sekä erilaisia luokka- ja pakettitason visualisointi- sekä selaustyökaluja~\cite{eclipse-ide}.

Ohjelmointiympäristöjä voi usein laajentaa lisäohjelmilla (plugin), joiden avulla ohjelmointiympäristöön voi tuoda lisäominaisuuksia~\cite{eclipse-ide}, kuten uuden työkalun auttamaan ongelmanratkaisussa tai tuen kielelle, jota ohjelmointiympäristö ei valmiiksi tue. Kuitenkaan kaikkia ohjelmoijan työtä helpottavia työkaluja ei ole sisäänrakennettu tai saatavissa lisäohjelmana ohjelmointiympäristöön. Esimerkiksi harva ohjelmointiympäristö osaa automaattisesti ottaa käyttöön ja ehdottaa ohjelmoijan tarvitsemaa ulkoista kirjastoa ja sen luokkia~\cite{jungloid-mining}. Siksi on tärkeää, että ohjelmoija osaa käyttää myös muita työkaluja.

\subsection{Dokumentaatio}
Isompien ohjelmistoprojektien ja muiden käyttöön tarkoitettujen ohjelmistokirjastojen kohdalla dokumentaation merkitys kasvaa, sillä koodin katselmointipohjainen omaksuminen ei onnistu enää nopeasti eikä ole kirjaston käyttäjän näkökulmasta järkevää. Ulkoisten ohjelmistojen tarkoituksena on se, että niiden käyttö onnistuu tuntematta tarkalleen kyseisen ohjelmakoodin toimintaa, vaan riittää, että ohjelmoija lukee tarvittavan dokumentaation ohjelmistokirjaston julkiseen käyttöön tarkoitetuista rajapinnoista.

Ohjelmakoodin yhteydessä olevan dokumentaation tarkoituksena on selventää kyseisen luokan käyttötarkoitusta ja toimintaa. Vastaavasti metodien yhteydessä oleva dokumentaatio avaa kyseisen metodin toiminnallisuutta~\cite{javadoc}.
Dokumentaation tavoitteena on siis saada koodin jatkokehittäjä taikka uudelleenkäyttäjä ymmärtämään koodin toiminta siinä määrin, että hänen ei tarvitse lukea ja tutustua kaikkeen ohjelmakoodiin, mikä on hidasta, vaan hän onnistuu lukemalla kompaktin dokumentaation sisäistämään nopeasti ohjelmakoodin toiminnan ja käyttötarkoituksen.
Osa dokumentaatiosta on usein suunnattu erityisesti jatkokehittäjille ja osa ohjelmiston loppukäyttäjälle.

Projektien dokumentaatiota on ohjelmakoodin seassa olevan dokumentaation lisäksi erillisissä tiedostoissa. Tällaiset dokumentit ovat projektissa ohjelmoineiden ohjelmoijien tekemiä sekä projektin tuotoksen käyttäjien luomia~\cite{using-wikis-in-sw}.
Ohjelmakoodista irrallaan oleva dokumentaatio tarjoaa useasti ohjeita ohjelmiston käyttöönottamiseen ja konfiguroimiseen sekä korjaa yleisiä väärinymmärryksiä ohjelmistosta ja sisältää muita projektiin sopivia ohjeita. Tämä dokumentaatio on tyypillisesti omassa kansiossaan ja readme-tiedostoissa tai ohjelmiston käytössä olevassa wiki-palvelussa~\cite{using-wikis-in-sw}. Wikipohjaisesta dokumentaatiosta kerron kappaleessa~\ref{ch:wiki}.

Ohjelmistojen dokumentaatio muodostuu siis sekä ohjelmakoodin yhteyteen kirjoitetusta dokumentaatiosta että ohjelmiston wikiin~\cite{using-wikis-in-sw} tai muualle koodista irralleen kirjotetuista ohjelmiston käytön ohjeista ja neuvoista.

Dokumentaation saatavuus on kuitenkin usein heikkoa ja ajantasaisen version löytäminen vaikeaa. \href{https://readthedocs.org/}{Read the Docs}\footnote{\url{https://readthedocs.org/}} pyrkii helpottamaan ohjelman dokumentaation julkaisua. Tavoitteena on, että yhä useampi projekti julkaisisi dokumentaationsa selkeästi kaikkien löydettäväksi ja luettavaksi. Read the Docs on myös loppukäyttäjien näkökulmasta muodostumassa luotettavaksi paikaksi hakea dokumentaatiota avoimen lähdekoodin ohjelmistoihin.

Dokumentaatiosta huolimatta uusien ohjelmointirajapintojen kohdalla on useasti vaikea hahmottaa ohjelmointirajapinnan rakenne ja sen tarjoamien luokkien suhteet toisiin luokkiin~\cite{jungloid-mining}. Jungloid-louhinta pyrkii helpottamaan uusien rajapintojen käyttöönottoa auttamalla ohjelmoijaa muuntamaan datan ohjelmistokirjaston tarvitsemaan muotoon. Kerron lisää Jungloid-louhinnasta kappaleessa~\ref{ch:jungloid}.

Dokumentaation lisäksi useat ohjelmistokirjastot tarjoavat esimerkkejä ohjelmistokirjaston käytöstä. Esimerkit ovat kuitenkin hyvin yksinkertaisia ja ne auttavat vain helpoissa asioissa alkuun pääsyssä. Monimutkaisemmissa tapauksissa niistä ei ole lainkaan iloa. Kuitenkin eri sivustoilla, kuten StackOverflowssa, jaetaan esimerkkikoodia vastauksina kysymyksiin. Nämä jaetut esimerkit kattavat usein tapauksia, joita ohjelmiston oma dokumentaatio taikka esimerkit eivät kata. Esittelen myöhemmin ExampleOverflown~\cite{example-overflow-social-media-for-code-recommendations}, joka pyrkii helpottamaan sopivan esimerkin löytämistä.

\subsection{Ongelman ratkaisu}
Harva työkalu tarjoaa vastauksia ohjelmoijan luonnollisella kielellä esittämiin kysymyksiin ohjelman toiminnasta: ne tarjoavat esimerkiksi ainoastaan mahdollisuuden tarkastella ohjelman tilaa suorituksen aikana, jättäen itse kysymykseen vastaamisen kokonaan ohjelmoijan vastuulle.

Shepherd ja Murphy ehdottavat ongelman ratkaisuprosessin aikana esiintulevien loogisten kysymysten vastaamiseen työkalua, joka tarkkailee ohjelmoijan toimintaa. Se tunnistaa automaattisesti kohdat, jossa ohjelmoijalla on tyypillisesti vaikeuksia ja ehdottaa sopivia työkaluja, joita käyttämällä ohjelmoija voisi edetä ja ratkaista kohtaamansa ongelman mahdollisimman tehokkaasti. Ajan mittaan työkalu opettaa ohjelmoijaa yhä tehokkaammin käyttämään tarjolla olevia työkaluja~\cite{programmers-coach}.

Ohjelmointiprosessin aikana ohjelmistokehittäjien ongelman ratkaisussa esittämien
kysymyksien vastaamiseen on luotu Whyline-ohjelma~\cite{whyline}, joka
pyrkii auttamaan ohjelmistokehittäjiä vastaamaalla seuraaviin kysymyksiin:

\begin{itemize}
  \item Miksi jokin toimii?
  \item Miksi jokin ei toimi odotetusti?
  \item Miksi jotain tapahtuu?
  \item Miksi jotain ei tapahdu?
\end{itemize}
Whyline ei kerro suoraan oikeaa vastausta, vaan ohjaa ja opastaa ongelmanratkaisuprosessissa työkalujen tehokkaaseen käyttöön ja siten vähentää ohjelmointiongelman ratkaisuun käytettyä aikaa~\cite{whyline}.

\subsection{Sopivan kirjaston löytäminen}
\label{ch:jungloid}
Vaikka avointa lähdekoodia ja erilaisia ohjelmistokirjastoja on tarjolla paljon, ei niiden uudelleenkäyttäminen ole kuitenkaan aina helppoa. Erityisen vaikeaa on sopivan kirjaston löytäminen omaan käyttötarkoitukseen.

Riskinä on, että ohjelmoija ei löydä käyttötarkoitukseen sopivaa kirjastoa vaan päätyy tuottamaan uutta koodia olemassaolevan koodin uusiokäytön sijaan. Jotkut ohjelmoijat haluavat myös mieluummin tuottaa kaiken koodin itse sen sijaan, että käyttäisivät aikaa tutustuakseen muiden tuottamaan koodiin ja jatkojalostaakseen sitä. Ohjelmoijat muistuttavat tässä pienimuotoisesti taiteilijoita~\cite{hackers-and-painters}.
Uutta koodia kannattaa kuitenkin kirjottaa vain, mikäli valmista toteutusta ei ole olemassa. Koodia uusiokäyttämällä säästyy olemassaolevan koodin uudelleen kirjoittamiselta ja samalla riski uusien virheiden tuottamisesta pienenee. Ohjelmakoodin uusiokäyttämisessä on kuitenkin riskinsä; ohjelmakoodissa voi olla tuntemattomia ohjelmointivirheitä, tietoturvariskejä tai käytössä oleva algoritmi saattaa olla aivan liian tehoton.

Ohjelmoijan avuksi on luotu S\raise0.5ex\hbox{6}-projekti ja Jungloid-louhinta, jotka helpottavat sopivan kirjaston löytämistä ja käyttöönottoa.

S\raise0.5ex\hbox{6}-projekti pyrkii helpottamaan sopivan koodin hakemista ja siten auttaa koodin uudelleenkäyttöä sekä erilaisten ohjelmistokirjastojen löytämistä. S\raise0.5ex\hbox{6}-projekti mahdollistaa sopivien luokkien ja metodien haun siten, että ohjelmoija tarjoaa testitapauksia, joiden rakennetta ja semantiikkaa automatisoidusti tarkastelemalla S\raise0.5ex\hbox{6}-projekti pystyy rajaamaan sen tuntemista ohjelmistokirjastoista testitapauksiin sopivat. S\raise0.5ex\hbox{6}-projekti pyrkii myös automatisoimaan tarvittavat muunnokset eri tyyppien välillä, jotta eriävät tyypit eivät rajoittaisi järjestelmän tarjoamia hakutuloksia liikaa~\cite{what-to-search-for}. Haku ei kuitenkaan tarjoa ainoastaan juuri ohjelmoijan tarjoamaan esimerkkiin sopivaa vastausta, vaan näyttää myös suurin piirtein siihen sopivia ratkaisuja. Tämä ominaisuus on kehitetty S\raise0.5ex\hbox{6}-projektiin siksi, että ohjelmoija tietää usein vain suuntaa-antavasti, mitä hän oikeasti tarvitsee.

S\raise0.5ex\hbox{6}-projektissa haku toimii juuri testitapausten semantiikkaa ja toimintaa analysoimalla, sillä sanallisesti kaivatun toiminnallisuuden ja tarvittavien avainsanojen keksiminen on vaikeaa~\cite{what-to-search-for}.

Jungloid-louhinta auttaa ohjelmoijaa tilanteessa, jossa ohjelmointirajapinta käyttää eri tyyppejä kuin mitä ohjelmoijalla on käytössä. Useasti rajapinta vaatii tietyn rajapinnan toteuttavan luokan. Tämän tyypin muuntaminen ohjelmistorajapinnan tarpeeseen sopivaan tyyppiin ei ole aina helppoa eikä suoraviivaista. Joskus tyyppi tulee kierrättää usean muun tyypin kautta, jotta kohdetyyppiin päästään tai ohjelmoijan tulee itse toteuttaa tyyppimuunnos ohjelmoijalla olevasta tyypistä ohjelmistorajapinnan haluamaan tyyppiin. Se tuottaa ohjelmoijalle paljon haasteita erityisesti silloin, jos tarjolla olevat tyypit eivät ole hänelle tuttuja.

Jungloid-louhinnan avulla ohjelmoijalle voidaan automatisoidusti tarjota erilaisia tapoja muuntaa ohjelmoijalla käytössä oleva tyyppi ohjelmointirajapinnan vaatimaan tyyppiin. Taustalla Jungloid-louhinta tietää kaikkien sen tuntemien tyyppien suhteet toisiinsa ja siten onnistuu verkkohakualgoritmejä käyttämällä löytämään toimivan tavan muuntaa saatavilla oleva tyyppi tarvittavan tyyppiseksi. Haun laadun parantamiseksi tyyppejä voidaan muunnella ja yleistää ennen haun suorittamista. Esimerkiksi perintää tai rajapintoja käyttävä luokka voidaan tulkita jonain yläluokan tyyppinä tai rajapinnan tyyppinä, ennen kuin jungloid-haku suoritetaan~\cite{jungloid-mining}.

\section{Sosiaalinen media ohjelmoijan apuna}
\label{section:kolmastk}
Sosiaalisesta mediasta on tullut arkipäivää kaikille internetin käyttäjille: esimerkiksi Facebookissa seurataan, mitä tuttavat ja lähipiiri tekevät parhaillaan ja Imdb:stä saa  suosituksia, mitä elokuvia kannattaisi katsoa.
Myös ammattilaisille on omia sosiaalisia medioita, kuten esimerkiksi StackOverflow ja GitHub, jotka ovat erityisesti ohjelmoijille suunnattuja sosiaalisia medioita. Niistä löytyy muun muassa esimerkkejä, joiden haku on oleellinen osa nykyaikaista ohjelmistokehitystä \cite{example-overflow-social-media-for-code-recommendations}.

\subsection{GitHub}
GitHub tarjoaa niin yksittäisille ohjelmistokehittäjille kuin organisaatioille keinon hallita julkisia ja yksityisiä ohjelmistovarantoja (repository) Git-versionhallintajärjestelmällä. GitHubissa on yli 5 miljoonaa avointa lähdekoodivarastoa ja lähes jokainen avoimen lähdekoodin projekti löytyy nykyisin sieltä.

Ison lähdekoodivarastomäärän hallintaa helpottamaan GitHubissa voi merkitä itseään mahdollisesti kiinnostavia lähdekoodivarastoja tähdellä. Tähdet on tarkoitettu nimenomaan kuvaamaan kiinnostusta ja auttamaan lähdekoodivarastojen löytymistä helposti myöhempää käyttöä varten - ei niinkään osoittamaan ohjelmoijan pitävän tai käyttävän kyseisen lähdekoodivaraston ohjelmaa~\cite{social-networking-meets-se}, kuten tähtimerkistä voisi olettaa. GitHubissa voi myös seurata muiden projekteja sekä sinne rekisteröityneitä käyttäjiä.

GitHub tarjoaa ohjelmointikielipohjaisen suodatuksen lähdekoodivarastojen tarkasteluun. Lisäksi GitHubista voi hakea ohjelmakoodia avainsanojen perusteella~\cite{social-networking-meets-se}. Kuten muissakin avainsanapohjaisissa hauissa avainsanojen keksiminen on haastavaa~\cite{what-to-search-for}, mutta sopivan ohjelmointirajapinnan käyttöesimerkin haku on taas muita työkaluja helpompaa, sillä sopivat avainsanat, luokat ja metodit ovat tyypillisesti silloin tiedossa. GitHubista esimerkin hakemisessa on myös se hyvä puoli, että koodia ei ole kirjoitettu vain esimerkiksi kuten StackOverflowssa, vaan se on oikeasti käytössä.

GitHub tarjoaa lähdekoodivarastojen yhteyteen kaikkien tai vain projektin omistajien muokattavissa olevan wikin, johon voi säilöä projektiin liittyvää dokumentaatiota, jota ei muuten olisi lainkaan tai se olisi lähdekoodivarannossa muun ohjelmakoodin seassa.

\subsection{StackOverflow}
Kysymys- ja vastauspalstat (Q\&A) ovat yleinen tapa hakea vastauksia ongelmiin kaikilla elämän osa-alueilla. Sama pätee ohjelmointikehityksessä: kysymys- ja vastauspalstoja käytetään paljon, etsittäessä sopivia ratkaisuja ongelmiin sekä haettaessa esimerkkejä tietyn ohjelmistokirjaston käyttöön. StackOverflow on erityisen suosittu ohjelmoijien keskuudessa. Sivusto keskittyy tarkasti pysymään olennaisessa eli ohjelmointiaiheisissa kysymyksissä ja niiden vastauksissa. Sivuston toimintaperiaate on yksinkertainen: se kerää käyttäjikseen ison osan aiheen asiantuntijoista, jotka vastaavat toistensa kysymyksiin. StackOverflowlla on kuukausittain yli 16 miljoonaa käyttäjää. Käyttäjät äänestävät jokaiseen kysymykseen tulleet vastaukset ja ne näytetään paremmuusjärjestyksessä. Näin sivulta omaan kysymykseensä vastausta etsivä ohjelmoija löytää nopeasti aiheeseen sopivimman, kunnollisen vastauksen~\cite{social-networking-meets-se}.

StackOverflown toiminta perustuu käyttäjien aktiivisuuteen ja tutkimuksissa on havaittu, että StackOverflowssa aktiivisesti kysymyksiin vastaavat käyttäjät ovat myös aktiivisia GitHubin käyttäjiä, kun taas passiiviset GitHubin käyttäjät ovat aktiivisempia kysymään kysymyksiä StackOverflowssa~\cite{stackoverflow-and-github}.

Monissa StackOverflown kysymyksissä on mukana toimimaton koodiesimerkki ja  vastauksissa puolestaan on tarjolla toimiva koodiesimerkki. Esimerkit ovat kuitenkin vaihtelevasti toimivia ja niistä löytyy satunnaisesti virheitä. Tämän vuoksi on tärkeää, että StackOverflown yhteisö arvioi toistensa vastauksia. Näin hyvät vastaukset nousevat heikompien ylle ja käyttäjien on helppo tunnistaa hyvät vastaukset ja niissä olevat toimivat koodiesimerkit.

\subsection{ExampleOverflow}
\label{ch:exampleoverflow}

StackOverflown ja muiden vastaavien sivustojen käyttäjien haasteeksi muodostuu valtava vastausten ja koodiesimerkkien määrä. Zagalskyn, Barzilayn ja Yehudain sivusto ExampleOverflow~\cite{example-overflow-social-media-for-code-recommendations} kokoaa StackOverflowsta parhaiksi vastauksiksi merkityt koodiesimerkit. Lisäksi se tarjoaa optimoidun haun niistä. ExampleOverflow tarjoaa koodihaussa aina viisi sopivinta vastausta ja vastauksen itselleen sopimattomaksi merkitessään käyttäjä saa tilalle aina seuraavaksi sopivimman vaihtoehdon. Sivusto tarjoaa suoraan koodiesimerkkejä, joiden alla on linkit alkuperäisiin kysymyksiin ja vastauksiin.

Sivuston tavoitteena on tehdä esimerkkien löytäminen mahdollisimman vaivattomaksi. Kirjoittajien havaintojen mukaan ExampleOverflow löytää sopivia esimerkkejä useissa tapauksissa yhtä hyvin tai paremmin kuin StackOverflow \cite{example-overflow-social-media-for-code-recommendations}.

\subsection{Wikit}
\label{ch:wiki}
Wikit ovat yhteisöllinen tapa luoda kattavia tietopankkeja, joissa usean ihmisen tietotaito ja osaaminen yhdistyvät luoden asiasta kiinnostuneille laadukasta materiaalia. Wikejä käytetään myös avoimen lähdekoodin ohjelmien dokumentointiin sekä parantamaan ohjelmointikirjastojen dokumentaatiota. Wikit koetaan sähköpostilistoja ja muita perinteisempiä keskustelu- sekä dokumentointimuotoja helpommiksi ja selkeämmiksi käyttää juuri yhteisöllisen muokkauksen ja tiedon ajantasaisuuden ansiosta~\cite{using-wikis-in-sw}.
Myös GitHub tarjoaa helppokäyttöisiä wikejä ohjelmistojen dokumentointiin~\cite{github-wiki}.

Wikipohjaisen dokumentaation muutokset tehdään suoraan internet-selaimella eikä ohjelmiston lähdekoodivarastoa tarvitse erikseen ladata muokatakseen dokumentaatiota. Näin wikien käyttö mahdollistaa sen, että myös ohjelmiston loppukäyttäjät voivat helposti muokata ja kehittää ohjelmiston dokumentaatiota. Tämä puolestaan lisää dokumentaation määrää ja laatua~\cite{wiki-social-knowledge-construction}.

% Huomatessaan et wikistä puuttuu jtn mitä ne osaa ja niistä se kuuluis sinne, niin porukka todennäköisesti lisää sen wikiin ja siten parantaa wikin laatua~\cite{wiki-social-knowledge-construction}.

\subsection{Blogit}
Sosiaalisen median kasvun myötä blogien käyttö on levinnyt myös ohjelmistokehittäjien keskuudessa. Isoissa avoimen lähdekoodin projekteissa, kuten PostgreSQL:ssä, Gnomessa ja Pythonissa, julkaistaan keskimäärin noin kahdeksan tunnin välein uusi blogijulkaisu. Julkaisut ovat keskimäärin 150-273 sanan pituisia ja niissä kerrotaan erilaisia lisätietoja ohjelmistoista. Julkaisuissa käsitellään muun muassa seuraavia aiheita~\cite{how-dev-blog}:
\begin{itemize}
  \item ohjelmiston vaatimukset
  \item ohjelmiston käyttöönotto ja jakelu
  \item suunnitteluratkaisut
  \item ylläpito
  \item prosessin koordinointi ja hallinta
\item lisätietoja siitä, miten asia on toteutettu ohjelmistossa.
\end{itemize}

Useimmiten aihe liittyy sellaiseen kokonaisuuteen, jonka parissa kirjoittaja on äskettäin työskennellyt \cite{how-dev-blog}.
Myös henkilökohtaiset ohjelmistokehittäjien blogit toimivat paikkana löytää tietoa uusista ohjelmointirajapintojen ominaisuuksista sekä esimerkkejä niistä. Blogien ympärille on muodostunut yhteisöjä, jotka käyvät keskusteluja blogijulkaisuista.

\section{Yhteenveto}

Sovelluksiin tehdään muutoksia pääosin kahdesta syystä: korjataan sovellukseen jääneitä virheitä tai lisätään ominaisuuksia. Usein alkuperäisen koodin tehnyt ohjelmoija ei enää ole käytettävissä, joten muutokset tekee henkilö, jolle ohjelman logiikka ja rakenne eivät ole tuttuja.
Toisen tekemään koodiin tutustuminen, ja erityisesti tutustumisen aloittaminen, on vaikeaa ja vie paljon aikaa. Koodin katselmointi, testaaminen ja virheenjäljittimellä koodin suoritusaikaisen tilan tarkastelu eivät ole aina kovin tehokkaita tapoja koodin toiminnan sisäistämiseksi ja siksi ohjelmoijan avuksi on luotu useita työkaluja.

Esittelin uuden ohjelmointitehtävän aloittamisen vaiheita, joiden avulla ohjelmoija pääsee mahdollisimman pikaisesti aloittamaan varsinaisen ohjelmointitehtävän. Ensin hänen täytyy valita työlistalta tärkein ohjelmointitehtävä ja sen jälkeen etsiä ohjelmointitehtävän oikea aloituskohta. Kun aloituskohta on selvillä, ohjelmoija muodostaa ohjelmointitehtävään liittyvästä koodista yleiskuvan tarkastelemalla riippuvuuksia, koodin rakennetta ja käytössä olevia ohjelmointirajapintoja. Näiden ollessa selvillä voi ohjelmoija aloittaa virheen korjauksen tai uuden ominaisuuden ohjelmoinnin.

Luvussa~\ref{section:tokatk} kuvasin työkaluja, jotka on tehty erilaisiin käyttötarkoituksiin ohjelmointityön tueksi. Keskeisiä ohjelmoijan apuvälineitä ovat ohjelmointiympäristö sekä ohjelmiston dokumentaatio.
Ongelman ratkaisuun on omia työkalujaan. Ohjelmistokehitysprosessin aikana tulevien kysymyksiin vastaamiseen liittyvät työkalut voivat esimerkiksi ohjata ohjelmoijaa käyttämään tehtävään tarkoitettuja työkaluja ja opettaa niiden tehokkaampaa käyttöä~\cite{programmers-coach}. Whyline puolestaan auttaa ohjelmoijaa vastaamaan luonnollisella kielellä esitettyihin kysymyksiin~\cite{whyline}.

Sopivan kirjaston löytäminen ei ole helppoa, mutta työkalut auttavat tässäkin:
esimerkiksi Jungloid-louhinnan avulla on mahdollista ratkaista suuri osa ohjelmointirajapintojen käyttöön ja tyyppeihin liittyvistä kysymyksistä~\cite{jungloid-mining}.
Ohjelmoijan kannattaa hyödyntää avuksi ja työn tueksi tehtyjä työkaluja ja opetella käyttämään niitä täysimääräisesti.

Esittelen myös, miten ohjelmoija voi hyödyntää työssään sosiaalista mediaa. Ohjelmoija voi hakea vastausta kysymyksiinsä kysymys- ja vastauspalstoilta tai hyödyntää olemassaolevaa koodia: GitHubista voi hakea käytössä olevaa ohjelmakoodia, kun taas StackOverFlowsta löytyy esimerkkikäyttöön tehtyjä koodipaloja ja vastauksia ohjelmoijien kysymyksiin.
Wikit helpottavat ohjelmistojen dokumentointia ja blogeista ohjelmoija voi saada lisäinformaatiota ja siten syventää osaamistaan.

Työkaluja on moneen käyttötarkoitukseen ja ne kehittyvät jatkuvasti. Ohjelmoijan on tarpeen tuntea eri työvälineet ja pyrkiä löytämään niistä itselleen sopivimmat ja opetella niiden käyttöä, jotta ohjelmointityö olisi mahdollisimman tehokasta.

\newpage
\bibliographystyle{babalpha-lf}
\bibliography{lahteet}

\end{document}

