\documentclass[finnish]{../tktltiki2}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

\usepackage{setspace}
% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---

\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

\usepackage[nottoc]{tocbibind}

\settocbibname{Lähteet}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}

\doublespacing

% --- tktltiki2 options ---
\title{Tiivistelmä}
\author{Jarmo Isotalo}
\date{\today}
\level{Tiivistelmä}
\abstract{Tiivistelmä}

\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page

% --- Main matter ---

\mainmatter
\section{Johdanto}
Isompien ohjelmistojen kehityksen aikana tulee useasti tilanteita, joissa kehittäjä päätyy itse toteuttamaan
tietorankenteen tai algoritmin, joka on jo toteutettu samassa projektissa. Andrian ja Jonathan esittävät artikkelissaan
''Identification on High-Level Consept in Source Core''\cite{marcus2001identification}
tavan tunnistaa ohjelmasta korkean tason konsepteja.

Andrian ja Jonathan tuovat esille metriikan, jolla nämä korkean tason konseptit voidaan tunnistaa koodista.
Lähestymistavassaan he hyödyntävät tiedonhaun (information retieval) tekniikkaa ('latent semantic indexing')
tunnistaakseen semanttisesen
samankaltaisuuden koodista.

Väittämiensä tueksi he suorittivat kokeen, jonka kohteena oli C-ohjelmointikielellä toteutettu ohjelmisto,
Mosaic (v2.7). Siinä he osoittivat, että XXX avulla he voivattunnistaa useita tarkempaa tutkimusta vaatiaa
samankaltaisuutta koodista.


\section{Paskaa?}
% johdantoa?
Ohjelmakoodin kopiointia taphtuu usien isommissa ohjelmointiprojekteissa. Osia lähdekoodista, funktioita ja
tietorakenteita kopioidaan osin tai kokonaan useista sysitä.

Aikaisempi tutkimus cloonien tunnistamiseen on pääosin keskittynyt tunnistamaan koodista samoja tai lähes samanlaisia
rakenteita. Artikkelissa esitetty lähestymistapa
%ADT = abstract data type

keskittyy tunnistamaan implemntaatiot High-level consepts; TODO: suomennos. esim. abstraktit tietorakenteet
Andrian ja Markus käyttävät esittemässään tekniikassa erästä tiedonhaku menetelmää, ``latent semantic indexing``,
jolla he staattisesti analysoivat järjestelmän, ja
tunnistavat semanttisia samankaltaisuuksia.

Andrianin ja Markuksen tekniikan tavoitteena on parantaa ja kehittää nykyisiä koodin cloonauksen tunnistus metodeja,
jotka perustuvat koodin rakenteelliseen analyysiin.
Eri metodien yhteiskäyttö tulee auttamaan cloonien tunnistuksen laadussa.


Väittämiensä tueksi he suorittivat kokeita C kielellä toteutettuun NCSA Mosaic (v2.7) ja osoittivat että tekniikkansa
avulla he voivat tunnistaaa useita tarkempaa
tutkimusta vaativia kohteita (lue: klooneja) koodista.

Andrian ja Markus korostavat, että kysinen tekniikka ei puhtaasti paljoasta kaikkia klooneja, vaan tarjoavat työkalun,
joka auttaa koodin analysoijaa keskittymään oleellisiin tiedostoihin.


Andrian ja Markus mainitsevat yleisiä syitä, miksi koodia kopioidaan, yksi niistä on metodin kopiointi ja sopivaksi
muokkaaminen. Tässä ohjelmoija kopioi lähes sopivan palan koodia, ja muokkaa sen tilanteeseen sopivaksi. Tässä
vaiheessa ohjelmoijasta on halvempaa jättää toinen copypaste metodi sellaisenaan kuin alkaa refaktoiroimaan koodia,
jotta copypaste metodi ei jäisi copypasteksi.
% hitto mikä lause


Andrian ja Markus esittelevät muutaman lähdekoodi kloonin tyypin
- Täydellinen klooni, on pala ohjelmakoodia, joka on identtinen kopio toiseen ohjelmakoodin palaan verrattaessa.
- Lähes täydellinen klooni (near miss clone) on pala joka on lähes täydllinen kopio. Tällaisia tulee kun ohjelmoija
muokkaa kopioitua koodia sopimaan paremmin omaan tarpeeseensa.
-


Andrian ja Markus esittelevät toisen syyn kloonien synnylle erityisesti isommissa ohjelmistoissa.

``Re-inventing the wheel'' eli ohjelmoija toteuttaa itse jo projektissa aiemmin toteutetun algoritmin tai tietorakenteen
, sen sijaan että käyttäisi projektissa aiemmin toteutettua. Syynä tähän voi olla puhtaasti tietämättömyys, että kysinen
tietorakenne on jo toteutettu, tai ohjelmoijan on vain helpompi toteuttaa olemassa oleva tietorakenne uusiksi vrt.
tutustua ja muokata olemassa olevaa tietorakennetta itselleen sopivaan tarkoitukseen.


Andrianin ja Markuksen mukaan nämä kloonit ovat useasti 'higher-level abstractations'. Yksinkertainen esimerki AST:sta
on ADT lista. Heidän mukaan useasti kopioinnin kohteeksi on päätynyt lista-tietorakenne.

Andrian ja Markus nimittävät näitä klooneja ``high-level copncept clones''.
Osa aiemmista kloonin tunnistus ohjelmistoista kykenee tunnistamaan osan tällaisista klooneista, ei mitään järjestelmää
ole tehty erityisesti näiden tunnistamiseen.

\section{Latent semantic indexing (LSI)}
On sanakirjaan perustuva tilastollinen menetelmä, jolla kuvataan sanojen ja lauseiden tarkoituksia.
Metodi generoi verkoti kuvauksen tekstin osista. Tätä esitystä voidaan käyttää vertailemaan ja indeksoimaan dokumenttejä
Menetelmän toimintatavan vuoksi se voi tunnistaa lähdekoogista merkitykselliset muuttujien nimet, vaikka ne eivät
olisi käytetyssä sanakirjassa, (esim. avg engl.lyhenne keskiarvolle).
% ei tää oikeesti kiinnosta ketään :DD



\section{High level conseptsien tunnistus}
Andrian ja Markus esittelevät tekniikan high-level kloonien tunnistamiseen; tämä tekniikka perustuu vertailtavien
koodien semanttiseen samankaltaisuuteen. Samankaltaisuus osien välillä lasketaan vertailemalla osien rakenteellista
informaatiota.

Nykyisessä muodossa menetelmä helpottaa kloonien löytämistä, mutta vaatii kuitenkin kehittäjän osallistumisen
duplikaattien  tunnistamiseen. Sillä, kun samankaltaisuudet koodista on laskettu, tulee käyttäjän valita valita
lähtökohdaksi joukko dokumenttejä, joiden tiedetään toteuttavan ADT:n.
Tässä käyttäjä voi hyödyntää olemassa olevia kloonin tunnistus sovellutuksia tai päätellä samankaltaisuudet tiedostojen
nimistä
Tässä käyttäjä voi hyödyntää olemassa olevia kloonin tunnistus sovellutuksia tai päätellä samankaltaisuudet tiedostojen
nimistä.

\begin{itemize}
  \item Source code document (dokument, d)
    on joukko lähdekoodin rivejä, useasti esim. functio, block of declarations tai luokan määäretelmä + siihen liittyvä
    dokumentaatio.

  \item A software system
    on joukko dokumenteistä $S = \{d_1,d_2\dots d_n\}$ %rpkl latex math
    kaikkien dokumenttien määrä $n = |S|$

  \item cluster $c_k$
  on joukko dokumenttejä $S$stä, siten että $c_k \subseteq S$ Klusterin koko on $|c_k|$

  \item file $f_i$
    koostuu useasta jatkuvasta doumentistä, ja on kaikkien tiedostojen yhdiste on $|S|$

  \item Järjestelmä esitetään verkkona
    $G=(S,E)$, missä nodet $S$ ovat dokumenttejä, $E$ on joukko painotettuja edgejä ja relaatio
    $e: E \to \{(d_i,d_j) | d_i, d_j \in S; d_i \neq d_j  \}$

% ei noita loppuja varmaan kannata kirjottaa\dots eikä varmaan näitäkään?
\end{itemize}
Kahta dokumenttiä pidetään samana, mikäli $\exists d_i \in f_i, d_j \in f_j $ siten että $sem(d_i, d_j) > \alpha$.
$sem$ on semanttisen samankaltaisuuden laskeva funktio. (kosini vektoreista ja $\alpha$ on rajaarvo $0,7$ eli $45$
asteen kulma)







\section{Selitä Semanttinen samankaltaisuus}

















\bibliographystyle{babplain-lf}
\bibliography{../lahteet.bib}

\end{document}
